#ifndef host_gecko_h
#define host_gecko_h

/*****************************************************************************
 *
 *  Native BGAPI
 *
 *  Autogenerated file, do not edit
 *
 ****************************************************************************/
 
#include <string.h>


#include "bg_types.h"

#include "gecko_configuration.h"

/* Compability */
#ifndef PACKSTRUCT
/*Default packed configuration*/
#ifdef __GNUC__
#ifdef _WIN32
#define PACKSTRUCT( decl ) decl __attribute__((__packed__,gcc_struct))
#else
#define PACKSTRUCT( decl ) decl __attribute__((__packed__))
#endif
#define ALIGNED __attribute__((aligned(0x4)))
#elif __IAR_SYSTEMS_ICC__

#define PACKSTRUCT( decl ) __packed decl

#define ALIGNED
#elif _MSC_VER  //msvc

#define PACKSTRUCT( decl ) __pragma( pack(push, 1) ) decl __pragma( pack(pop) )
#define ALIGNED
#else 
#define PACKSTRUCT(a) a PACKED 
#endif
#endif


#define BGLIB_MSG_ID(HDR) ((HDR)&0xffff00f8)
#define BGLIB_MSG_HEADER_LEN (4)
#define BGLIB_MSG_LEN(HDR) ((((HDR)&0x7)<<8)|(((HDR)&0xff00)>>8))

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Blocks until new event arrives which requires processing by user application.
 * 
 * @return pointer to received event
 */
struct gecko_cmd_packet* gecko_wait_event(void);

/**
 * Same as gecko_wait_event but does not block if no events waiting, instead returns NULL
 *
 * @return pointer to received event or NULL if no event waiting
 */
struct gecko_cmd_packet* gecko_peek_event(void);

/**
 * Events are in queue waiting for processing
 * Call gecko_wait_event or gecko_peek_event to process pending events
 *
 * @return nonzero if processing required
 */
int gecko_event_pending(void);

/**
 *  Initialize stack
 *  @param config if set as NULL uses default values for all configuration parameters
 */
void gecko_init(const gecko_configuration_t *config);


enum bt_gap_discover_mode
{
	bt_gap_discover_limited = 1,
	bt_gap_discover_generic = 0,
	bt_gap_discover_mode_max= 1
};

enum le_gap_address_type
{
	le_gap_address_type_public          = 0,
	le_gap_address_type_random          = 1,
	le_gap_address_type_public_identity = 2,
	le_gap_address_type_random_identity = 3,
	le_gap_address_type_bredr           = 16,
	le_gap_address_type_max             = 17
};

enum le_gap_connectable_mode
{
	le_gap_non_connectable           = 0,
	le_gap_directed_connectable      = 1,
	le_gap_undirected_connectable    = 2,
	le_gap_scannable_non_connectable = 3,
	le_gap_connectable_mode_max      = 4
};

enum le_gap_discoverable_mode
{
	le_gap_non_discoverable     = 0,
	le_gap_limited_discoverable = 1,
	le_gap_general_discoverable = 2,
	le_gap_broadcast            = 3,
	le_gap_user_data            = 4,
	le_gap_discoverable_mode_max= 5
};

enum le_gap_discover_mode
{
	le_gap_discover_limited     = 0,
	le_gap_discover_generic     = 1,
	le_gap_discover_observation = 2,
	le_gap_discover_mode_max    = 3
};

enum bt_connection_direction
{
	bt_connection_outgoing = 0,
	bt_connection_incoming = 1,
	bt_connection_direction_max= 2
};

enum bt_connection_powermode
{
	bt_connection_active = 0,
	bt_connection_sniff  = 2,
	bt_connection_powermode_max= 3
};

enum bt_connection_role
{
	bt_connection_master = 0,
	bt_connection_slave  = 1,
	bt_connection_role_max= 2
};

enum bt_connection_encryption
{
	bt_connection_encrypted = 0,
	bt_connection_plain     = 1,
	bt_connection_encryption_max= 2
};

enum le_connection_security
{
	le_connection_mode1_level1 = 0,
	le_connection_mode1_level2 = 1,
	le_connection_mode1_level3 = 2,
	le_connection_security_max = 3
};

enum gatt_att_opcode
{
	gatt_read_by_type_request      = 0x08,
	gatt_read_by_type_response     = 0x09,
	gatt_read_request              = 0x0a,
	gatt_read_response             = 0x0b,
	gatt_read_blob_request         = 0x0c,
	gatt_read_blob_response        = 0x0d,
	gatt_read_multiple_request     = 0x0e,
	gatt_read_multiple_response    = 0x0f,
	gatt_write_request             = 0x12,
	gatt_write_response            = 0x13,
	gatt_write_command             = 0x52,
	gatt_prepare_write_request     = 0x16,
	gatt_prepare_write_response    = 0x17,
	gatt_execute_write_request     = 0x18,
	gatt_execute_write_response    = 0x19,
	gatt_handle_value_notification = 0x1b,
	gatt_handle_value_indication   = 0x1d,
	gatt_att_opcode_max            = 30
};

enum gatt_client_config_flag
{
	gatt_notification = 0x1,
	gatt_indication   = 0x2,
	gatt_client_config_flag_max= 3
};

enum gatt_execute_write_flag
{
	gatt_cancel = 0x0,
	gatt_commit = 0x1,
	gatt_execute_write_flag_max= 2
};

enum gatt_server_characteristic_status_flag
{
	gatt_server_client_config = 0x1,
	gatt_server_confirmation  = 0x2,
	gatt_server_characteristic_status_flag_max= 3
};

#define ENDPOINT_FLAG_UPDATED    0x01
#define ENDPOINT_FLAG_ACTIVE     0x02
#define ENDPOINT_FLAG_STREAMING  0x04
#define ENDPOINT_FLAG_BGAPI      0x08
#define ENDPOINT_FLAG_WAIT_CLOSE 0x10
#define ENDPOINT_FLAG_CLOSING    0x20

enum endpoint_types
{
	endpoint_free       = 0x0,
	endpoint_uart       = 0x1,
	endpoint_script     = 0x2,
	endpoint_reserved   = 0x4,
	endpoint_drop       = 0x10,
	endpoint_rfcomm     = 0x20,
	endpoint_spi        = 0x40,
	endpoint_connection = 0x80,
	endpoint_native     = 0x100,
	endpoint_iap        = 0x200,
	endpoint_types_max  = 513
};

enum hardware_gpio_mode
{
	hardware_gpio_mode_disabled          = 0x0,
	hardware_gpio_mode_input             = 0x1,
	hardware_gpio_mode_input_pull        = 0x2,
	hardware_gpio_mode_input_pull_filter = 0x3,
	hardware_gpio_mode_push_pull         = 0x4,
	hardware_gpio_mode_max               = 5
};

#define FLASH_PS_KEY_BD_ADDR                     1
#define FLASH_PS_KEY_LOCAL_NAME                  4
#define FLASH_PS_KEY_BT_CLASS                    5
#define FLASH_PS_KEY_IWRAP_PAGE_MODE             6
#define FLASH_PS_KEY_IWRAP_PAGE_TIMEOUT          7
#define FLASH_PS_KEY_IWRAP_PAGE_SCAN_MODE        8
#define FLASH_PS_KEY_IWRAP_ALT_PAGE_MODE         9
#define FLASH_PS_KEY_IWRAP_PAGE_CONN_COUNT       10
#define FLASH_PS_KEY_IWRAP_MS_POLICY             11
#define FLASH_PS_KEY_IWRAP_LINK_POLICY           12
#define FLASH_PS_KEY_IWRAP_SUPERVISION_TIMEOUT   13
#define FLASH_PS_KEY_SNIFF_MAX_INTERVAL          14
#define FLASH_PS_KEY_SNIFF_MIN_INTERVAL          15
#define FLASH_PS_KEY_SNIFF_ATTEMPTS              16
#define FLASH_PS_KEY_SNIFF_TIMEOUT               17
#define FLASH_PS_KEY_IO_CAPABILITIES             18
#define FLASH_PS_KEY_MITM                        19
#define FLASH_PS_KEY_IWRAP_CONTROL_ECHO          20
#define FLASH_PS_KEY_UART_SPEED                  21
#define FLASH_PS_KEY_PROFILE_SPP                 22
#define FLASH_PS_KEY_PORTA_PIO_DIRECTION         23
#define FLASH_PS_KEY_PORTB_PIO_DIRECTION         24
#define FLASH_PS_KEY_PORTA_PIO_BIAS              25
#define FLASH_PS_KEY_PORTB_PIO_BIAS              26
#define FLASH_PS_KEY_PORTA_PIO_PULL_UP           27
#define FLASH_PS_KEY_PORTB_PIO_PULL_UP           28
#define FLASH_PS_KEY_IWRAP_I2C_STATUS            29
#define FLASH_PS_KEY_IWRAP_SPI_STATUS            30
#define FLASH_PS_KEY_MAXPAIRCOUNT                31
#define FLASH_PS_KEY_LAST_DELETED_PAIR           32
#define FLASH_PS_KEY_IWRAP_CD_MASK               33
#define FLASH_PS_KEY_IWRAP_CD_DATA_MASK          34
#define FLASH_PS_KEY_IWRAP_CD_MODE               35
#define FLASH_PS_KEY_IWRAP_AUTH_PIN_VISIBLE      36
#define FLASH_PS_KEY_AUTH_PIN                    37
#define FLASH_PS_KEY_IWRAP_READY_MASK            38
#define FLASH_PS_KEY_IWRAP_ESC_CHAR              39
#define FLASH_PS_KEY_IWRAP_DTR_PIO_MASK          40
#define FLASH_PS_KEY_IWRAP_DTR_MODE              41
#define FLASH_PS_KEY_MINIMUM_ENCRYPTION_KEY_SIZE 42
#define FLASH_PS_KEY_INQUIRY_SCAN_LAP            43
#define FLASH_PS_KEY_LOCAL_BD_ADDR               44
#define FLASH_PS_KEY_AUTOCALL                    45
#define FLASH_PS_KEY_AUTOCALL_DUMMY              46
#define FLASH_PS_KEY_LAP                         47
#define FLASH_PS_KEY_CONNAUTH                    48
#define FLASH_PS_KEY_TX_POWER                    49

enum test_packet_type
{
	test_pkt_prbs9    = 0x0,
	test_pkt_11110000 = 0x1,
	test_pkt_10101010 = 0x2,
	test_packet_type_max= 3
};

enum sm_bonding_key
{
	sm_bonding_key_ltk         = 0x01,
	sm_bonding_key_addr_public = 0x02,
	sm_bonding_key_addr_static = 0x04,
	sm_bonding_key_irk         = 0x08,
	sm_bonding_key_edivrand    = 0x10,
	sm_bonding_key_csrk        = 0x20,
	sm_bonding_key_masterid    = 0x40,
	sm_bonding_key_max         = 65
};

enum sm_io_capability
{
	sm_io_capability_displayonly     = 0,
	sm_io_capability_displayyesno    = 1,
	sm_io_capability_keyboardonly    = 2,
	sm_io_capability_noinputnooutput = 3,
	sm_io_capability_keyboarddisplay = 4,
	sm_io_capability_max             = 5
};


enum gecko_parameter_types
{
    gecko_msg_parameter_uint8=2,
    gecko_msg_parameter_int8=3,
    gecko_msg_parameter_uint16=4,
    gecko_msg_parameter_int16=5,
    gecko_msg_parameter_uint32=6,
    gecko_msg_parameter_int32=7,
    gecko_msg_parameter_uint8array=8,
    gecko_msg_parameter_string=9,
    gecko_msg_parameter_hwaddr=10,
    gecko_msg_parameter_uint16array=11
};

enum gecko_msg_types
{
    gecko_msg_type_cmd=0x00,
    gecko_msg_type_rsp=0x00,
    gecko_msg_type_evt=0x80
};
enum gecko_dev_types
{
    gecko_dev_type_ble    =0x00,
    gecko_dev_type_wifi   =0x08,
    gecko_dev_type_iwrap  =0x10,
    gecko_dev_type_dumo   =0x20,
    gecko_dev_type_test   =0x20,
    gecko_dev_type_gecko   =0x20
};

#define	gecko_cmd_dfu_reset_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00000000)
#define	gecko_cmd_dfu_flash_set_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01000000)
#define	gecko_cmd_dfu_flash_upload_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02000000)
#define	gecko_cmd_dfu_flash_upload_finish_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03000000)
#define	gecko_cmd_system_hello_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00010000)
#define	gecko_cmd_system_reset_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01010000)
#define	gecko_cmd_system_get_bt_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03010000)
#define	gecko_cmd_le_gap_open_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00030000)
#define	gecko_cmd_le_gap_set_mode_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01030000)
#define	gecko_cmd_le_gap_discover_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02030000)
#define	gecko_cmd_le_gap_end_procedure_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03030000)
#define	gecko_cmd_le_gap_set_adv_parameters_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04030000)
#define	gecko_cmd_le_gap_set_conn_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05030000)
#define	gecko_cmd_le_gap_set_scan_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06030000)
#define	gecko_cmd_le_gap_set_adv_data_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07030000)
#define	gecko_cmd_le_connection_set_parameters_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00080000)
#define	gecko_cmd_gatt_set_max_mtu_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00090000)
#define	gecko_cmd_gatt_discover_primary_services_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01090000)
#define	gecko_cmd_gatt_discover_primary_services_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02090000)
#define	gecko_cmd_gatt_discover_characteristics_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03090000)
#define	gecko_cmd_gatt_discover_characteristics_by_uuid_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04090000)
#define	gecko_cmd_gatt_set_characteristic_notification_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05090000)
#define	gecko_cmd_gatt_discover_descriptors_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06090000)
#define	gecko_cmd_gatt_read_characteristic_value_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07090000)
#define	gecko_cmd_gatt_read_characteristic_value_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08090000)
#define	gecko_cmd_gatt_write_characteristic_value_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09090000)
#define	gecko_cmd_gatt_write_characteristic_value_without_response_id	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0A090000)
#define	gecko_cmd_gatt_prepare_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B090000)
#define	gecko_cmd_gatt_execute_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0C090000)
#define	gecko_cmd_gatt_send_characteristic_confirmation_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0D090000)
#define	gecko_cmd_gatt_read_descriptor_value_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0E090000)
#define	gecko_cmd_gatt_write_descriptor_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0F090000)
#define	gecko_cmd_gatt_find_included_services_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10090000)
#define	gecko_cmd_gatt_read_multiple_characteristic_values_id        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11090000)
#define	gecko_cmd_gatt_server_read_attribute_value_id                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000A0000)
#define	gecko_cmd_gatt_server_read_attribute_type_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010A0000)
#define	gecko_cmd_gatt_server_write_attribute_value_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020A0000)
#define	gecko_cmd_gatt_server_send_user_read_response_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030A0000)
#define	gecko_cmd_gatt_server_send_user_write_response_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040A0000)
#define	gecko_cmd_gatt_server_send_characteristic_notification_id    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050A0000)
#define	gecko_cmd_endpoint_send_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000B0000)
#define	gecko_cmd_endpoint_set_streaming_destination_id              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010B0000)
#define	gecko_cmd_endpoint_close_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020B0000)
#define	gecko_cmd_endpoint_set_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030B0000)
#define	gecko_cmd_endpoint_clr_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040B0000)
#define	gecko_cmd_endpoint_read_counters_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050B0000)
#define	gecko_cmd_hardware_set_soft_timer_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000C0000)
#define	gecko_cmd_hardware_configure_gpio_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010C0000)
#define	gecko_cmd_hardware_write_gpio_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020C0000)
#define	gecko_cmd_hardware_read_gpio_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030C0000)
#define	gecko_cmd_hardware_read_adc_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040C0000)
#define	gecko_cmd_hardware_read_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050C0000)
#define	gecko_cmd_hardware_write_i2c_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060C0000)
#define	gecko_cmd_hardware_stop_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070C0000)
#define	gecko_cmd_flash_ps_dump_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000D0000)
#define	gecko_cmd_flash_ps_erase_all_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010D0000)
#define	gecko_cmd_flash_ps_save_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020D0000)
#define	gecko_cmd_flash_ps_load_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030D0000)
#define	gecko_cmd_flash_ps_erase_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040D0000)
#define	gecko_cmd_test_dtm_tx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000E0000)
#define	gecko_cmd_test_dtm_rx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010E0000)
#define	gecko_cmd_test_dtm_end_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020E0000)
#define	gecko_cmd_sm_set_bondable_mode_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000F0000)
#define	gecko_cmd_sm_configure_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010F0000)
#define	gecko_cmd_sm_store_bonding_configuration_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020F0000)
#define	gecko_cmd_sm_increase_security_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040F0000)
#define	gecko_cmd_sm_delete_bonding_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060F0000)
#define	gecko_cmd_sm_delete_bondings_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070F0000)
#define	gecko_cmd_sm_enter_passkey_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080F0000)
#define	gecko_cmd_sm_list_all_bondings_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0B0F0000)
#define	gecko_rsp_dfu_reset_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00000000)
#define	gecko_rsp_dfu_flash_set_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01000000)
#define	gecko_rsp_dfu_flash_upload_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02000000)
#define	gecko_rsp_dfu_flash_upload_finish_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03000000)
#define	gecko_rsp_system_hello_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00010000)
#define	gecko_rsp_system_reset_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01010000)
#define	gecko_rsp_system_get_bt_address_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03010000)
#define	gecko_rsp_le_gap_open_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00030000)
#define	gecko_rsp_le_gap_set_mode_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01030000)
#define	gecko_rsp_le_gap_discover_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02030000)
#define	gecko_rsp_le_gap_end_procedure_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03030000)
#define	gecko_rsp_le_gap_set_adv_parameters_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04030000)
#define	gecko_rsp_le_gap_set_conn_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05030000)
#define	gecko_rsp_le_gap_set_scan_parameters_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06030000)
#define	gecko_rsp_le_gap_set_adv_data_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07030000)
#define	gecko_rsp_le_connection_set_parameters_id                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00080000)
#define	gecko_rsp_gatt_set_max_mtu_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00090000)
#define	gecko_rsp_gatt_discover_primary_services_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01090000)
#define	gecko_rsp_gatt_discover_primary_services_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02090000)
#define	gecko_rsp_gatt_discover_characteristics_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03090000)
#define	gecko_rsp_gatt_discover_characteristics_by_uuid_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04090000)
#define	gecko_rsp_gatt_set_characteristic_notification_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05090000)
#define	gecko_rsp_gatt_discover_descriptors_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06090000)
#define	gecko_rsp_gatt_read_characteristic_value_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07090000)
#define	gecko_rsp_gatt_read_characteristic_value_by_uuid_id          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08090000)
#define	gecko_rsp_gatt_write_characteristic_value_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09090000)
#define	gecko_rsp_gatt_write_characteristic_value_without_response_id	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0A090000)
#define	gecko_rsp_gatt_prepare_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B090000)
#define	gecko_rsp_gatt_execute_characteristic_value_write_id         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0C090000)
#define	gecko_rsp_gatt_send_characteristic_confirmation_id           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0D090000)
#define	gecko_rsp_gatt_read_descriptor_value_id                      	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0E090000)
#define	gecko_rsp_gatt_write_descriptor_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0F090000)
#define	gecko_rsp_gatt_find_included_services_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10090000)
#define	gecko_rsp_gatt_read_multiple_characteristic_values_id        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11090000)
#define	gecko_rsp_gatt_server_read_attribute_value_id                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000A0000)
#define	gecko_rsp_gatt_server_read_attribute_type_id                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010A0000)
#define	gecko_rsp_gatt_server_write_attribute_value_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020A0000)
#define	gecko_rsp_gatt_server_send_user_read_response_id             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030A0000)
#define	gecko_rsp_gatt_server_send_user_write_response_id            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040A0000)
#define	gecko_rsp_gatt_server_send_characteristic_notification_id    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050A0000)
#define	gecko_rsp_endpoint_send_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000B0000)
#define	gecko_rsp_endpoint_set_streaming_destination_id              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010B0000)
#define	gecko_rsp_endpoint_close_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020B0000)
#define	gecko_rsp_endpoint_set_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030B0000)
#define	gecko_rsp_endpoint_clr_flags_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040B0000)
#define	gecko_rsp_endpoint_read_counters_id                          	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050B0000)
#define	gecko_rsp_hardware_set_soft_timer_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000C0000)
#define	gecko_rsp_hardware_configure_gpio_id                         	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010C0000)
#define	gecko_rsp_hardware_write_gpio_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020C0000)
#define	gecko_rsp_hardware_read_gpio_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030C0000)
#define	gecko_rsp_hardware_read_adc_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040C0000)
#define	gecko_rsp_hardware_read_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050C0000)
#define	gecko_rsp_hardware_write_i2c_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060C0000)
#define	gecko_rsp_hardware_stop_i2c_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070C0000)
#define	gecko_rsp_flash_ps_dump_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000D0000)
#define	gecko_rsp_flash_ps_erase_all_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010D0000)
#define	gecko_rsp_flash_ps_save_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020D0000)
#define	gecko_rsp_flash_ps_load_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030D0000)
#define	gecko_rsp_flash_ps_erase_id                                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040D0000)
#define	gecko_rsp_test_dtm_tx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000E0000)
#define	gecko_rsp_test_dtm_rx_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010E0000)
#define	gecko_rsp_test_dtm_end_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020E0000)
#define	gecko_rsp_sm_set_bondable_mode_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000F0000)
#define	gecko_rsp_sm_configure_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010F0000)
#define	gecko_rsp_sm_store_bonding_configuration_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020F0000)
#define	gecko_rsp_sm_increase_security_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040F0000)
#define	gecko_rsp_sm_delete_bonding_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060F0000)
#define	gecko_rsp_sm_delete_bondings_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070F0000)
#define	gecko_rsp_sm_enter_passkey_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080F0000)
#define	gecko_rsp_sm_list_all_bondings_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0B0F0000)
#define	gecko_evt_dfu_boot_id                                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00000000)
#define	gecko_evt_system_boot_id                                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00010000)
#define	gecko_evt_le_gap_scan_response_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00030000)
#define	gecko_evt_le_connection_opened_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00080000)
#define	gecko_evt_le_connection_closed_id                            	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01080000)
#define	gecko_evt_le_connection_parameters_id                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02080000)
#define	gecko_evt_gatt_mtu_exchanged_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00090000)
#define	gecko_evt_gatt_service_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01090000)
#define	gecko_evt_gatt_characteristic_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02090000)
#define	gecko_evt_gatt_descriptor_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03090000)
#define	gecko_evt_gatt_characteristic_value_id                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04090000)
#define	gecko_evt_gatt_descriptor_value_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05090000)
#define	gecko_evt_gatt_procedure_completed_id                        	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06090000)
#define	gecko_evt_gatt_server_attribute_value_id                     	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000A0000)
#define	gecko_evt_gatt_server_user_read_request_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010A0000)
#define	gecko_evt_gatt_server_user_write_request_id                  	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020A0000)
#define	gecko_evt_gatt_server_characteristic_status_id               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030A0000)
#define	gecko_evt_endpoint_syntax_error_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000B0000)
#define	gecko_evt_endpoint_data_id                                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010B0000)
#define	gecko_evt_endpoint_status_id                                 	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020B0000)
#define	gecko_evt_endpoint_closing_id                                	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030B0000)
#define	gecko_evt_hardware_soft_timer_id                             	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000C0000)
#define	gecko_evt_hardware_interrupt_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010C0000)
#define	gecko_evt_flash_ps_key_id                                    	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000D0000)
#define	gecko_evt_test_dtm_completed_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000E0000)
#define	gecko_evt_sm_passkey_display_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000F0000)
#define	gecko_evt_sm_passkey_request_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010F0000)
#define	gecko_evt_sm_confirm_passkey_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020F0000)
#define	gecko_evt_sm_bonded_id                                       	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030F0000)
#define	gecko_evt_sm_bonding_failed_id                               	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040F0000)
#define	gecko_evt_sm_list_bonding_entry_id                           	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x050F0000)
#define	gecko_evt_sm_list_all_bondings_complete_id                   	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x060F0000)
#define	gecko_evt_sm_bonding_request_id                              	(((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x070F0000)
#include "bg_errorcodes.h"
PACKSTRUCT( struct gecko_msg_dfu_reset_cmd_t
{
	uint8	dfu;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_cmd_t
{
	uint32	address;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_cmd_t
{
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_flash_upload_finish_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_dfu_boot_evt_t
{
	uint32	version;
});

PACKSTRUCT( struct gecko_msg_system_hello_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_reset_cmd_t
{
	uint8	dfu;
});

PACKSTRUCT( struct gecko_msg_system_set_max_power_mode_cmd_t
{
	uint8	power_mode;
});

PACKSTRUCT( struct gecko_msg_system_set_max_power_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_bt_address_rsp_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_system_set_bt_address_cmd_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_system_set_bt_address_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_class_of_device_rsp_t
{
	uint32	cod;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_set_class_of_device_cmd_t
{
	uint32	cod;
});

PACKSTRUCT( struct gecko_msg_system_set_class_of_device_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_reset_factory_settings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_set_local_name_cmd_t
{
	uint8array	name;
});

PACKSTRUCT( struct gecko_msg_system_set_local_name_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_system_get_local_name_rsp_t
{
	uint16	result;
	uint8array	name;
});

PACKSTRUCT( struct gecko_msg_system_boot_evt_t
{
	uint16	major;
	uint16	minor;
	uint16	patch;
	uint16	build;
	uint16	bootloader;
	uint16	hw;
});

PACKSTRUCT( struct gecko_msg_system_initialized_evt_t
{
	bd_addr	address;
});

PACKSTRUCT( struct gecko_msg_le_gap_open_cmd_t
{
	bd_addr	address;
	uint8	address_type;
});

PACKSTRUCT( struct gecko_msg_le_gap_open_rsp_t
{
	uint16	result;
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_mode_cmd_t
{
	uint8	discover;
	uint8	connect;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_discover_cmd_t
{
	uint8	mode;
});

PACKSTRUCT( struct gecko_msg_le_gap_discover_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_end_procedure_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_cmd_t
{
	uint16	interval_min;
	uint16	interval_max;
	uint8	channel_map;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_cmd_t
{
	uint16	min_interval;
	uint16	max_interval;
	uint16	latency;
	uint16	timeout;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_cmd_t
{
	uint16	scan_interval;
	uint16	scan_window;
	uint8	active;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_cmd_t
{
	uint8	scan_rsp;
	uint8array	adv_data;
});

PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_gap_scan_response_evt_t
{
	int8	rssi;
	uint8	packet_type;
	bd_addr	address;
	uint8	address_type;
	uint8	bonding;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_cmd_t
{
	uint8	connection;
	uint16	min_interval;
	uint16	max_interval;
	uint16	latency;
	uint16	timeout;
});

PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_le_connection_opened_evt_t
{
	bd_addr	address;
	uint8	address_type;
	uint8	master;
	uint8	connection;
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_le_connection_closed_evt_t
{
	uint16	reason;
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_le_connection_parameters_evt_t
{
	uint8	connection;
	uint16	interval;
	uint16	latency;
	uint16	timeout;
	uint8	security_mode;
});

PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_cmd_t
{
	uint16	max_mtu;
});

PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t
{
	uint8	connection;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_cmd_t
{
	uint8	connection;
	uint32	service;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_cmd_t
{
	uint8	connection;
	uint16	characteristic;
});

PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_cmd_t
{
	uint8	connection;
	uint16	characteristic;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t
{
	uint8	connection;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_cmd_t
{
	uint8	connection;
	uint16	descriptor;
});

PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_cmd_t
{
	uint8	connection;
	uint16	descriptor;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_find_included_services_cmd_t
{
	uint8	connection;
	uint32	service;
});

PACKSTRUCT( struct gecko_msg_gatt_find_included_services_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t
{
	uint8	connection;
	uint8array	characteristic_list;
});

PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_mtu_exchanged_evt_t
{
	uint8	connection;
	uint16	mtu;
});

PACKSTRUCT( struct gecko_msg_gatt_service_evt_t
{
	uint8	connection;
	uint32	service;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_characteristic_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	properties;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_descriptor_evt_t
{
	uint8	connection;
	uint16	descriptor;
	uint8array	uuid;
});

PACKSTRUCT( struct gecko_msg_gatt_characteristic_value_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_descriptor_value_evt_t
{
	uint8	connection;
	uint16	descriptor;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_procedure_completed_evt_t
{
	uint8	connection;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_cmd_t
{
	uint16	attribute;
	uint16	offset;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_rsp_t
{
	uint16	result;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_cmd_t
{
	uint16	attribute;
});

PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_rsp_t
{
	uint16	result;
	uint8array	type;
});

PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_cmd_t
{
	uint16	attribute;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_errorcode;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_errorcode;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t
{
	uint8	connection;
	uint16	characteristic;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_gatt_server_attribute_value_evt_t
{
	uint8	connection;
	uint16	attribute;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_user_read_request_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
});

PACKSTRUCT( struct gecko_msg_gatt_server_user_write_request_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	att_opcode;
	uint16	offset;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_gatt_server_characteristic_status_evt_t
{
	uint8	connection;
	uint16	characteristic;
	uint8	status_flags;
	uint16	client_config_flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_send_cmd_t
{
	uint8	endpoint;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_endpoint_send_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_cmd_t
{
	uint8	endpoint;
	uint8	destination_endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_close_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_close_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_flags_cmd_t
{
	uint8	endpoint;
	uint32	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_set_flags_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_cmd_t
{
	uint8	endpoint;
	uint32	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_rsp_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_read_counters_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_read_counters_rsp_t
{
	uint16	result;
	uint8	endpoint;
	uint32	tx;
	uint32	rx;
});

PACKSTRUCT( struct gecko_msg_endpoint_syntax_error_evt_t
{
	uint16	result;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_endpoint_data_evt_t
{
	uint8	endpoint;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_endpoint_status_evt_t
{
	uint8	endpoint;
	uint32	type;
	int8	destination_endpoint;
	uint8	flags;
});

PACKSTRUCT( struct gecko_msg_endpoint_closing_evt_t
{
	uint16	reason;
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_cmd_t
{
	uint32	time;
	uint8	handle;
	uint8	single_shot;
});

PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_configure_gpio_cmd_t
{
	uint8	port;
	uint8	gpio;
	uint8	mode;
	uint8	output;
});

PACKSTRUCT( struct gecko_msg_hardware_configure_gpio_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_write_gpio_cmd_t
{
	uint8	port;
	uint16	mask;
	uint16	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_gpio_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_read_gpio_cmd_t
{
	uint8	port;
	uint16	mask;
});

PACKSTRUCT( struct gecko_msg_hardware_read_gpio_rsp_t
{
	uint16	result;
	uint16	data;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_cmd_t
{
	uint8	port;
	uint8	pin;
});

PACKSTRUCT( struct gecko_msg_hardware_read_adc_rsp_t
{
	uint16	result;
	uint16	value;
});

PACKSTRUCT( struct gecko_msg_hardware_read_i2c_cmd_t
{
	uint8	channel;
	uint16	slave_address;
	uint8	length;
});

PACKSTRUCT( struct gecko_msg_hardware_read_i2c_rsp_t
{
	uint16	result;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_i2c_cmd_t
{
	uint8	channel;
	uint16	slave_address;
	uint8array	data;
});

PACKSTRUCT( struct gecko_msg_hardware_write_i2c_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_stop_i2c_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_hardware_stop_i2c_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_hardware_soft_timer_evt_t
{
	uint8	handle;
});

PACKSTRUCT( struct gecko_msg_hardware_interrupt_evt_t
{
	uint32	interrupts;
	uint32	timestamp;
});

PACKSTRUCT( struct gecko_msg_flash_ps_dump_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_all_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_save_cmd_t
{
	uint16	key;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_flash_ps_save_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_load_cmd_t
{
	uint16	key;
});

PACKSTRUCT( struct gecko_msg_flash_ps_load_rsp_t
{
	uint16	result;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_cmd_t
{
	uint16	key;
});

PACKSTRUCT( struct gecko_msg_flash_ps_erase_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_flash_ps_key_evt_t
{
	uint16	key;
	uint8array	value;
});

PACKSTRUCT( struct gecko_msg_test_dtm_tx_cmd_t
{
	uint8	packet_type;
	uint8	length;
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_dtm_tx_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_rx_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_dtm_rx_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_end_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_tx_test_cmd_t
{
	uint8	modulation;
	uint8	channel;
	uint8	power;
});

PACKSTRUCT( struct gecko_msg_test_tx_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_debug_enable_cmd_t
{
	uint8	id;
	uint8	enable;
});

PACKSTRUCT( struct gecko_msg_test_ssp_debug_cmd_t
{
	uint8	enable;
});

PACKSTRUCT( struct gecko_msg_test_debug_command_cmd_t
{
	uint8	id;
	uint8array	debugdata;
});

PACKSTRUCT( struct gecko_msg_test_debug_command_rsp_t
{
	uint16	result;
	uint8	id;
	uint8array	debugdata;
});

PACKSTRUCT( struct gecko_msg_test_device_under_test_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_pts_msc_cmd_t
{
	uint8	endpoint;
});

PACKSTRUCT( struct gecko_msg_test_pts_msc_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_rx_test_cmd_t
{
	uint8	channel;
});

PACKSTRUCT( struct gecko_msg_test_rx_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_packet_test_cmd_t
{
	uint8	mode;
	uint8	tx_freq;
	uint8	rx_freq;
	uint8	acl_type;
	uint16	acl_len;
	uint8	power;
	uint8	disable_whitening;
});

PACKSTRUCT( struct gecko_msg_test_packet_test_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_test_dtm_completed_evt_t
{
	uint16	result;
	uint16	number_of_packets;
});

PACKSTRUCT( struct gecko_msg_test_debug_evt_t
{
	uint16	id;
	uint16	u32;
	uint8array	stuff;
});

PACKSTRUCT( struct gecko_msg_test_hcidump_evt_t
{
	uint32	time;
	uint8	direction;
	uint8	packet_type;
	uint16array	data;
});

PACKSTRUCT( struct gecko_msg_test_error_evt_t
{
	uint16	param1;
	uint8array	param2;
});

PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_cmd_t
{
	uint8	bondable;
});

PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_configure_cmd_t
{
	uint8	mitm_required;
	uint8	io_capabilities;
});

PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_cmd_t
{
	uint8	max_bonding_count;
	uint8	policy_flags;
});

PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_configuration_rsp_t
{
	uint8	max_bonding_count;
	uint8	policy_flags;
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_increase_security_cmd_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_sm_increase_security_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_cmd_t
{
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_read_bonding_rsp_t
{
	uint16	result;
	bd_addr	address;
	uint8	address_type;
	uint8array	bonding_key;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bonding_cmd_t
{
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bonding_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_delete_bondings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_enter_passkey_cmd_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_enter_passkey_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_cmd_t
{
	uint8	connection;
	uint8	confirm;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_set_oob_data_cmd_t
{
	uint8array	oob;
});

PACKSTRUCT( struct gecko_msg_sm_list_all_bondings_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_confirm_bonding_rsp_t
{
	uint16	result;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_display_evt_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_passkey_request_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_msg_sm_confirm_passkey_evt_t
{
	uint8	connection;
	uint32	passkey;
});

PACKSTRUCT( struct gecko_msg_sm_bonded_evt_t
{
	uint8	connection;
	uint8	bonding;
});

PACKSTRUCT( struct gecko_msg_sm_bonding_failed_evt_t
{
	uint8	connection;
	uint16	reason;
});

PACKSTRUCT( struct gecko_msg_sm_list_bonding_entry_evt_t
{
	uint8	bonding;
	bd_addr	address;
	uint8	address_type;
});

PACKSTRUCT( struct gecko_msg_sm_bonding_request_evt_t
{
	uint8	connection;
});

PACKSTRUCT( struct gecko_cmd_packet
{
	uint32   header;

union{
	uint8 handle;

	uint8 payload[128];/*TODO: fix this in nativeclient_parser.py*/

	struct gecko_msg_dfu_reset_cmd_t                                        cmd_dfu_reset;
	struct gecko_msg_dfu_flash_set_address_cmd_t                            cmd_dfu_flash_set_address;
	struct gecko_msg_dfu_flash_upload_cmd_t                                 cmd_dfu_flash_upload;
	struct gecko_msg_dfu_boot_evt_t                                         evt_dfu_boot;
	struct gecko_msg_dfu_flash_set_address_rsp_t                            rsp_dfu_flash_set_address;
	struct gecko_msg_dfu_flash_upload_rsp_t                                 rsp_dfu_flash_upload;
	struct gecko_msg_dfu_flash_upload_finish_rsp_t                          rsp_dfu_flash_upload_finish;
	struct gecko_msg_system_reset_cmd_t                                     cmd_system_reset;
	struct gecko_msg_system_set_max_power_mode_cmd_t                        cmd_system_set_max_power_mode;
	struct gecko_msg_system_set_bt_address_cmd_t                            cmd_system_set_bt_address;
	struct gecko_msg_system_set_class_of_device_cmd_t                       cmd_system_set_class_of_device;
	struct gecko_msg_system_set_local_name_cmd_t                            cmd_system_set_local_name;
	struct gecko_msg_system_boot_evt_t                                      evt_system_boot;
	struct gecko_msg_system_initialized_evt_t                               evt_system_initialized;
	struct gecko_msg_system_hello_rsp_t                                     rsp_system_hello;
	struct gecko_msg_system_set_max_power_mode_rsp_t                        rsp_system_set_max_power_mode;
	struct gecko_msg_system_get_bt_address_rsp_t                            rsp_system_get_bt_address;
	struct gecko_msg_system_set_bt_address_rsp_t                            rsp_system_set_bt_address;
	struct gecko_msg_system_get_class_of_device_rsp_t                       rsp_system_get_class_of_device;
	struct gecko_msg_system_set_class_of_device_rsp_t                       rsp_system_set_class_of_device;
	struct gecko_msg_system_reset_factory_settings_rsp_t                    rsp_system_reset_factory_settings;
	struct gecko_msg_system_set_local_name_rsp_t                            rsp_system_set_local_name;
	struct gecko_msg_system_get_local_name_rsp_t                            rsp_system_get_local_name;
	struct gecko_msg_le_gap_open_cmd_t                                      cmd_le_gap_open;
	struct gecko_msg_le_gap_set_mode_cmd_t                                  cmd_le_gap_set_mode;
	struct gecko_msg_le_gap_discover_cmd_t                                  cmd_le_gap_discover;
	struct gecko_msg_le_gap_set_adv_parameters_cmd_t                        cmd_le_gap_set_adv_parameters;
	struct gecko_msg_le_gap_set_conn_parameters_cmd_t                       cmd_le_gap_set_conn_parameters;
	struct gecko_msg_le_gap_set_scan_parameters_cmd_t                       cmd_le_gap_set_scan_parameters;
	struct gecko_msg_le_gap_set_adv_data_cmd_t                              cmd_le_gap_set_adv_data;
	struct gecko_msg_le_gap_scan_response_evt_t                             evt_le_gap_scan_response;
	struct gecko_msg_le_gap_open_rsp_t                                      rsp_le_gap_open;
	struct gecko_msg_le_gap_set_mode_rsp_t                                  rsp_le_gap_set_mode;
	struct gecko_msg_le_gap_discover_rsp_t                                  rsp_le_gap_discover;
	struct gecko_msg_le_gap_end_procedure_rsp_t                             rsp_le_gap_end_procedure;
	struct gecko_msg_le_gap_set_adv_parameters_rsp_t                        rsp_le_gap_set_adv_parameters;
	struct gecko_msg_le_gap_set_conn_parameters_rsp_t                       rsp_le_gap_set_conn_parameters;
	struct gecko_msg_le_gap_set_scan_parameters_rsp_t                       rsp_le_gap_set_scan_parameters;
	struct gecko_msg_le_gap_set_adv_data_rsp_t                              rsp_le_gap_set_adv_data;
	struct gecko_msg_le_connection_set_parameters_cmd_t                     cmd_le_connection_set_parameters;
	struct gecko_msg_le_connection_opened_evt_t                             evt_le_connection_opened;
	struct gecko_msg_le_connection_closed_evt_t                             evt_le_connection_closed;
	struct gecko_msg_le_connection_parameters_evt_t                         evt_le_connection_parameters;
	struct gecko_msg_le_connection_set_parameters_rsp_t                     rsp_le_connection_set_parameters;
	struct gecko_msg_gatt_set_max_mtu_cmd_t                                 cmd_gatt_set_max_mtu;
	struct gecko_msg_gatt_discover_primary_services_cmd_t                   cmd_gatt_discover_primary_services;
	struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t           cmd_gatt_discover_primary_services_by_uuid;
	struct gecko_msg_gatt_discover_characteristics_cmd_t                    cmd_gatt_discover_characteristics;
	struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t            cmd_gatt_discover_characteristics_by_uuid;
	struct gecko_msg_gatt_set_characteristic_notification_cmd_t             cmd_gatt_set_characteristic_notification;
	struct gecko_msg_gatt_discover_descriptors_cmd_t                        cmd_gatt_discover_descriptors;
	struct gecko_msg_gatt_read_characteristic_value_cmd_t                   cmd_gatt_read_characteristic_value;
	struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t           cmd_gatt_read_characteristic_value_by_uuid;
	struct gecko_msg_gatt_write_characteristic_value_cmd_t                  cmd_gatt_write_characteristic_value;
	struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t cmd_gatt_write_characteristic_value_without_response;
	struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t          cmd_gatt_prepare_characteristic_value_write;
	struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t          cmd_gatt_execute_characteristic_value_write;
	struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t            cmd_gatt_send_characteristic_confirmation;
	struct gecko_msg_gatt_read_descriptor_value_cmd_t                       cmd_gatt_read_descriptor_value;
	struct gecko_msg_gatt_write_descriptor_value_cmd_t                      cmd_gatt_write_descriptor_value;
	struct gecko_msg_gatt_find_included_services_cmd_t                      cmd_gatt_find_included_services;
	struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t         cmd_gatt_read_multiple_characteristic_values;
	struct gecko_msg_gatt_mtu_exchanged_evt_t                               evt_gatt_mtu_exchanged;
	struct gecko_msg_gatt_service_evt_t                                     evt_gatt_service;
	struct gecko_msg_gatt_characteristic_evt_t                              evt_gatt_characteristic;
	struct gecko_msg_gatt_descriptor_evt_t                                  evt_gatt_descriptor;
	struct gecko_msg_gatt_characteristic_value_evt_t                        evt_gatt_characteristic_value;
	struct gecko_msg_gatt_descriptor_value_evt_t                            evt_gatt_descriptor_value;
	struct gecko_msg_gatt_procedure_completed_evt_t                         evt_gatt_procedure_completed;
	struct gecko_msg_gatt_set_max_mtu_rsp_t                                 rsp_gatt_set_max_mtu;
	struct gecko_msg_gatt_discover_primary_services_rsp_t                   rsp_gatt_discover_primary_services;
	struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t           rsp_gatt_discover_primary_services_by_uuid;
	struct gecko_msg_gatt_discover_characteristics_rsp_t                    rsp_gatt_discover_characteristics;
	struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t            rsp_gatt_discover_characteristics_by_uuid;
	struct gecko_msg_gatt_set_characteristic_notification_rsp_t             rsp_gatt_set_characteristic_notification;
	struct gecko_msg_gatt_discover_descriptors_rsp_t                        rsp_gatt_discover_descriptors;
	struct gecko_msg_gatt_read_characteristic_value_rsp_t                   rsp_gatt_read_characteristic_value;
	struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t           rsp_gatt_read_characteristic_value_by_uuid;
	struct gecko_msg_gatt_write_characteristic_value_rsp_t                  rsp_gatt_write_characteristic_value;
	struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t rsp_gatt_write_characteristic_value_without_response;
	struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t          rsp_gatt_prepare_characteristic_value_write;
	struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t          rsp_gatt_execute_characteristic_value_write;
	struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t            rsp_gatt_send_characteristic_confirmation;
	struct gecko_msg_gatt_read_descriptor_value_rsp_t                       rsp_gatt_read_descriptor_value;
	struct gecko_msg_gatt_write_descriptor_value_rsp_t                      rsp_gatt_write_descriptor_value;
	struct gecko_msg_gatt_find_included_services_rsp_t                      rsp_gatt_find_included_services;
	struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t         rsp_gatt_read_multiple_characteristic_values;
	struct gecko_msg_gatt_server_read_attribute_value_cmd_t                 cmd_gatt_server_read_attribute_value;
	struct gecko_msg_gatt_server_read_attribute_type_cmd_t                  cmd_gatt_server_read_attribute_type;
	struct gecko_msg_gatt_server_write_attribute_value_cmd_t                cmd_gatt_server_write_attribute_value;
	struct gecko_msg_gatt_server_send_user_read_response_cmd_t              cmd_gatt_server_send_user_read_response;
	struct gecko_msg_gatt_server_send_user_write_response_cmd_t             cmd_gatt_server_send_user_write_response;
	struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t     cmd_gatt_server_send_characteristic_notification;
	struct gecko_msg_gatt_server_attribute_value_evt_t                      evt_gatt_server_attribute_value;
	struct gecko_msg_gatt_server_user_read_request_evt_t                    evt_gatt_server_user_read_request;
	struct gecko_msg_gatt_server_user_write_request_evt_t                   evt_gatt_server_user_write_request;
	struct gecko_msg_gatt_server_characteristic_status_evt_t                evt_gatt_server_characteristic_status;
	struct gecko_msg_gatt_server_read_attribute_value_rsp_t                 rsp_gatt_server_read_attribute_value;
	struct gecko_msg_gatt_server_read_attribute_type_rsp_t                  rsp_gatt_server_read_attribute_type;
	struct gecko_msg_gatt_server_write_attribute_value_rsp_t                rsp_gatt_server_write_attribute_value;
	struct gecko_msg_gatt_server_send_user_read_response_rsp_t              rsp_gatt_server_send_user_read_response;
	struct gecko_msg_gatt_server_send_user_write_response_rsp_t             rsp_gatt_server_send_user_write_response;
	struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t     rsp_gatt_server_send_characteristic_notification;
	struct gecko_msg_endpoint_send_cmd_t                                    cmd_endpoint_send;
	struct gecko_msg_endpoint_set_streaming_destination_cmd_t               cmd_endpoint_set_streaming_destination;
	struct gecko_msg_endpoint_close_cmd_t                                   cmd_endpoint_close;
	struct gecko_msg_endpoint_set_flags_cmd_t                               cmd_endpoint_set_flags;
	struct gecko_msg_endpoint_clr_flags_cmd_t                               cmd_endpoint_clr_flags;
	struct gecko_msg_endpoint_read_counters_cmd_t                           cmd_endpoint_read_counters;
	struct gecko_msg_endpoint_syntax_error_evt_t                            evt_endpoint_syntax_error;
	struct gecko_msg_endpoint_data_evt_t                                    evt_endpoint_data;
	struct gecko_msg_endpoint_status_evt_t                                  evt_endpoint_status;
	struct gecko_msg_endpoint_closing_evt_t                                 evt_endpoint_closing;
	struct gecko_msg_endpoint_send_rsp_t                                    rsp_endpoint_send;
	struct gecko_msg_endpoint_set_streaming_destination_rsp_t               rsp_endpoint_set_streaming_destination;
	struct gecko_msg_endpoint_close_rsp_t                                   rsp_endpoint_close;
	struct gecko_msg_endpoint_set_flags_rsp_t                               rsp_endpoint_set_flags;
	struct gecko_msg_endpoint_clr_flags_rsp_t                               rsp_endpoint_clr_flags;
	struct gecko_msg_endpoint_read_counters_rsp_t                           rsp_endpoint_read_counters;
	struct gecko_msg_hardware_set_soft_timer_cmd_t                          cmd_hardware_set_soft_timer;
	struct gecko_msg_hardware_configure_gpio_cmd_t                          cmd_hardware_configure_gpio;
	struct gecko_msg_hardware_write_gpio_cmd_t                              cmd_hardware_write_gpio;
	struct gecko_msg_hardware_read_gpio_cmd_t                               cmd_hardware_read_gpio;
	struct gecko_msg_hardware_read_adc_cmd_t                                cmd_hardware_read_adc;
	struct gecko_msg_hardware_read_i2c_cmd_t                                cmd_hardware_read_i2c;
	struct gecko_msg_hardware_write_i2c_cmd_t                               cmd_hardware_write_i2c;
	struct gecko_msg_hardware_stop_i2c_cmd_t                                cmd_hardware_stop_i2c;
	struct gecko_msg_hardware_soft_timer_evt_t                              evt_hardware_soft_timer;
	struct gecko_msg_hardware_interrupt_evt_t                               evt_hardware_interrupt;
	struct gecko_msg_hardware_set_soft_timer_rsp_t                          rsp_hardware_set_soft_timer;
	struct gecko_msg_hardware_configure_gpio_rsp_t                          rsp_hardware_configure_gpio;
	struct gecko_msg_hardware_write_gpio_rsp_t                              rsp_hardware_write_gpio;
	struct gecko_msg_hardware_read_gpio_rsp_t                               rsp_hardware_read_gpio;
	struct gecko_msg_hardware_read_adc_rsp_t                                rsp_hardware_read_adc;
	struct gecko_msg_hardware_read_i2c_rsp_t                                rsp_hardware_read_i2c;
	struct gecko_msg_hardware_write_i2c_rsp_t                               rsp_hardware_write_i2c;
	struct gecko_msg_hardware_stop_i2c_rsp_t                                rsp_hardware_stop_i2c;
	struct gecko_msg_flash_ps_save_cmd_t                                    cmd_flash_ps_save;
	struct gecko_msg_flash_ps_load_cmd_t                                    cmd_flash_ps_load;
	struct gecko_msg_flash_ps_erase_cmd_t                                   cmd_flash_ps_erase;
	struct gecko_msg_flash_ps_key_evt_t                                     evt_flash_ps_key;
	struct gecko_msg_flash_ps_dump_rsp_t                                    rsp_flash_ps_dump;
	struct gecko_msg_flash_ps_erase_all_rsp_t                               rsp_flash_ps_erase_all;
	struct gecko_msg_flash_ps_save_rsp_t                                    rsp_flash_ps_save;
	struct gecko_msg_flash_ps_load_rsp_t                                    rsp_flash_ps_load;
	struct gecko_msg_flash_ps_erase_rsp_t                                   rsp_flash_ps_erase;
	struct gecko_msg_test_dtm_tx_cmd_t                                      cmd_test_dtm_tx;
	struct gecko_msg_test_dtm_rx_cmd_t                                      cmd_test_dtm_rx;
	struct gecko_msg_test_tx_test_cmd_t                                     cmd_test_tx_test;
	struct gecko_msg_test_debug_enable_cmd_t                                cmd_test_debug_enable;
	struct gecko_msg_test_ssp_debug_cmd_t                                   cmd_test_ssp_debug;
	struct gecko_msg_test_debug_command_cmd_t                               cmd_test_debug_command;
	struct gecko_msg_test_pts_msc_cmd_t                                     cmd_test_pts_msc;
	struct gecko_msg_test_rx_test_cmd_t                                     cmd_test_rx_test;
	struct gecko_msg_test_packet_test_cmd_t                                 cmd_test_packet_test;
	struct gecko_msg_test_dtm_completed_evt_t                               evt_test_dtm_completed;
	struct gecko_msg_test_debug_evt_t                                       evt_test_debug;
	struct gecko_msg_test_hcidump_evt_t                                     evt_test_hcidump;
	struct gecko_msg_test_error_evt_t                                       evt_test_error;
	struct gecko_msg_test_dtm_tx_rsp_t                                      rsp_test_dtm_tx;
	struct gecko_msg_test_dtm_rx_rsp_t                                      rsp_test_dtm_rx;
	struct gecko_msg_test_dtm_end_rsp_t                                     rsp_test_dtm_end;
	struct gecko_msg_test_tx_test_rsp_t                                     rsp_test_tx_test;
	struct gecko_msg_test_debug_command_rsp_t                               rsp_test_debug_command;
	struct gecko_msg_test_device_under_test_mode_rsp_t                      rsp_test_device_under_test_mode;
	struct gecko_msg_test_pts_msc_rsp_t                                     rsp_test_pts_msc;
	struct gecko_msg_test_rx_test_rsp_t                                     rsp_test_rx_test;
	struct gecko_msg_test_packet_test_rsp_t                                 rsp_test_packet_test;
	struct gecko_msg_sm_set_bondable_mode_cmd_t                             cmd_sm_set_bondable_mode;
	struct gecko_msg_sm_configure_cmd_t                                     cmd_sm_configure;
	struct gecko_msg_sm_store_bonding_configuration_cmd_t                   cmd_sm_store_bonding_configuration;
	struct gecko_msg_sm_increase_security_cmd_t                             cmd_sm_increase_security;
	struct gecko_msg_sm_read_bonding_cmd_t                                  cmd_sm_read_bonding;
	struct gecko_msg_sm_delete_bonding_cmd_t                                cmd_sm_delete_bonding;
	struct gecko_msg_sm_enter_passkey_cmd_t                                 cmd_sm_enter_passkey;
	struct gecko_msg_sm_passkey_confirm_cmd_t                               cmd_sm_passkey_confirm;
	struct gecko_msg_sm_set_oob_data_cmd_t                                  cmd_sm_set_oob_data;
	struct gecko_msg_sm_passkey_display_evt_t                               evt_sm_passkey_display;
	struct gecko_msg_sm_passkey_request_evt_t                               evt_sm_passkey_request;
	struct gecko_msg_sm_confirm_passkey_evt_t                               evt_sm_confirm_passkey;
	struct gecko_msg_sm_bonded_evt_t                                        evt_sm_bonded;
	struct gecko_msg_sm_bonding_failed_evt_t                                evt_sm_bonding_failed;
	struct gecko_msg_sm_list_bonding_entry_evt_t                            evt_sm_list_bonding_entry;
	struct gecko_msg_sm_bonding_request_evt_t                               evt_sm_bonding_request;
	struct gecko_msg_sm_set_bondable_mode_rsp_t                             rsp_sm_set_bondable_mode;
	struct gecko_msg_sm_store_bonding_configuration_rsp_t                   rsp_sm_store_bonding_configuration;
	struct gecko_msg_sm_read_bonding_configuration_rsp_t                    rsp_sm_read_bonding_configuration;
	struct gecko_msg_sm_increase_security_rsp_t                             rsp_sm_increase_security;
	struct gecko_msg_sm_read_bonding_rsp_t                                  rsp_sm_read_bonding;
	struct gecko_msg_sm_delete_bonding_rsp_t                                rsp_sm_delete_bonding;
	struct gecko_msg_sm_delete_bondings_rsp_t                               rsp_sm_delete_bondings;
	struct gecko_msg_sm_enter_passkey_rsp_t                                 rsp_sm_enter_passkey;
	struct gecko_msg_sm_passkey_confirm_rsp_t                               rsp_sm_passkey_confirm;
	struct gecko_msg_sm_list_all_bondings_rsp_t                             rsp_sm_list_all_bondings;
	struct gecko_msg_sm_confirm_bonding_rsp_t                               rsp_sm_confirm_bonding;
})data;

};
extern struct gecko_cmd_packet* gecko_cmd_msg;
extern struct gecko_cmd_packet* gecko_rsp_msg;
void gecko_handle_command(uint32_t,void*);
void gecko_handle_command_noresponse(uint32_t,void*);
/**This command can be used to reset the system. This command does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) after re-boot. **/
static inline void* gecko_cmd_dfu_reset(uint8 dfu) 
{
	gecko_cmd_msg->data.cmd_dfu_reset.dfu=dfu;
	gecko_cmd_msg->header=gecko_cmd_dfu_reset_id+((1+0)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
	return 0;
}
/**After re-booting the local device into DFU mode, this command can be used to define the starting address on the flash where the new firmware will be written in.**/
static inline struct gecko_msg_dfu_flash_set_address_rsp_t* gecko_cmd_dfu_flash_set_address(uint32 address) 
{
	gecko_cmd_msg->data.cmd_dfu_flash_set_address.address=address;
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_set_address_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_set_address;
}
/**This command is used to upload the firmware update file to the Bluetooth module. The payload of the command is 128 bytes, so multiple commands need to be used to upload the full firmware image file.**/
static inline struct gecko_msg_dfu_flash_upload_rsp_t* gecko_cmd_dfu_flash_upload(uint8 data_len,uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_dfu_flash_upload.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_dfu_flash_upload.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_id+((1+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
}
/**This command can be used to tell to the device that the DFU file has been fully uploaded. To return the device back to normal mode the command {a href="#cmd_dfu_reset"}cmd_dfu_reset{/a} must be issued next.**/
static inline struct gecko_msg_dfu_flash_upload_finish_rsp_t* gecko_cmd_dfu_flash_upload_finish() 
{
	gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_finish_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_dfu_flash_upload_finish;
}
/**This command does not trigger any event but the response to the command is used to verify that communication between the host and the module is working.**/
static inline struct gecko_msg_system_hello_rsp_t* gecko_cmd_system_hello() 
{
	gecko_cmd_msg->header=gecko_cmd_system_hello_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_hello;
}
/**
            This command can be used to reset the system. It does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) depending on the selected BOOT mode.**/
static inline void* gecko_cmd_system_reset(uint8 dfu) 
{
	gecko_cmd_msg->data.cmd_system_reset.dfu=dfu;
	gecko_cmd_msg->header=gecko_cmd_system_reset_id+((1+0)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
	return 0;
}
/**This command can be used to read the local Bluetooth address used by the module.**/
static inline struct gecko_msg_system_get_bt_address_rsp_t* gecko_cmd_system_get_bt_address() 
{
	gecko_cmd_msg->header=gecko_cmd_system_get_bt_address_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_system_get_bt_address;
}
/**This command can be used to start the GAP discovery procedure to scan for advertising devices i.e. to perform a device discovery. Scanning parameters can be configured with the le_gap_set_scan_parameters command before issuing this command. To cancel on an ongoing discovery process use the le_gap_end_procedure command.**/
static inline struct gecko_msg_le_gap_open_rsp_t* gecko_cmd_le_gap_open(bd_addr address,uint8 address_type) 
{
	memcpy(&gecko_cmd_msg->data.cmd_le_gap_open.address,&address,sizeof(bd_addr));
	gecko_cmd_msg->data.cmd_le_gap_open.address_type=address_type;
	gecko_cmd_msg->header=gecko_cmd_le_gap_open_id+((7+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_open;
}
/**This command can be used to configure the current Bluetooth LE GAP Connectable and Discoverable modes. It can be used to enable advertisements and/or allow incoming connections. To exit from this mode (to stop advertising) use the command le_gap_end_procedure.**/
static inline struct gecko_msg_le_gap_set_mode_rsp_t* gecko_cmd_le_gap_set_mode(uint8 discover,uint8 connect) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_mode.discover=discover;
	gecko_cmd_msg->data.cmd_le_gap_set_mode.connect=connect;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_mode_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_mode;
}
/**This command can be used to start Bluetooth LE discovery procedure.**/
static inline struct gecko_msg_le_gap_discover_rsp_t* gecko_cmd_le_gap_discover(uint8 mode) 
{
	gecko_cmd_msg->data.cmd_le_gap_discover.mode=mode;
	gecko_cmd_msg->header=gecko_cmd_le_gap_discover_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_discover;
}
/**This command can be used to end a current GAP procedure.**/
static inline struct gecko_msg_le_gap_end_procedure_rsp_t* gecko_cmd_le_gap_end_procedure() 
{
	gecko_cmd_msg->header=gecko_cmd_le_gap_end_procedure_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_end_procedure;
}
/**This command can be used to set Bluetooth LE advertisement parameters.**/
static inline struct gecko_msg_le_gap_set_adv_parameters_rsp_t* gecko_cmd_le_gap_set_adv_parameters(uint16 interval_min,uint16 interval_max,uint8 channel_map) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_min=interval_min;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_max=interval_max;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.channel_map=channel_map;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_parameters_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_adv_parameters;
}
/**This command can be used to set the default Bluetooth LE connection parameters. The configured values are valid for all subsequent connections that will be established. For changing the parameters of an already established connection use the command le_connection_set_parameters.**/
static inline struct gecko_msg_le_gap_set_conn_parameters_rsp_t* gecko_cmd_le_gap_set_conn_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.min_interval=min_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.max_interval=max_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.latency=latency;
	gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.timeout=timeout;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_conn_parameters_id+((8+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_conn_parameters;
}
/**This command can be used to set Bluetooth LE scan parameters.**/
static inline struct gecko_msg_le_gap_set_scan_parameters_rsp_t* gecko_cmd_le_gap_set_scan_parameters(uint16 scan_interval,uint16 scan_window,uint8 active) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_interval=scan_interval;
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_window=scan_window;
	gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.active=active;
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_scan_parameters_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_scan_parameters;
}
/**This command can be used to set the data in advertisement packets or in the scan response packets. This data is used when advertising in user data mode. It is recommended to set both the advertisement data and scan response data at the same time.**/
static inline struct gecko_msg_le_gap_set_adv_data_rsp_t* gecko_cmd_le_gap_set_adv_data(uint8 scan_rsp,uint8 adv_data_len,uint8* adv_data_data) 
{
	gecko_cmd_msg->data.cmd_le_gap_set_adv_data.scan_rsp=scan_rsp;
	gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.len=adv_data_len;
	memcpy(gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
	gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_data_id+((2+adv_data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
}
/**This command can be used to request a change in the BLE connection parameters of the currently active link.**/
static inline struct gecko_msg_le_connection_set_parameters_rsp_t* gecko_cmd_le_connection_set_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout) 
{
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.connection=connection;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.min_interval=min_interval;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.max_interval=max_interval;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.latency=latency;
	gecko_cmd_msg->data.cmd_le_connection_set_parameters.timeout=timeout;
	gecko_cmd_msg->header=gecko_cmd_le_connection_set_parameters_id+((9+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_le_connection_set_parameters;
}
/**This command can be used to set the maximum number of GATT Message Transfer Units (MTU). If max_mtu is non-default, MTU is exchanged automatically after Bluetooth LE connection has been established.**/
static inline struct gecko_msg_gatt_set_max_mtu_rsp_t* gecko_cmd_gatt_set_max_mtu(uint16 max_mtu) 
{
	gecko_cmd_msg->data.cmd_gatt_set_max_mtu.max_mtu=max_mtu;
	gecko_cmd_msg->header=gecko_cmd_gatt_set_max_mtu_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_set_max_mtu;
}
/**This command can be used to discover all the primary services of a remote GATT database. This command generates a unique gatt_service event for every discovered primary service. Received gatt_procedure_completed event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_primary_services_rsp_t* gecko_cmd_gatt_discover_primary_services(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services;
}
/**This command can be used to discover primary services with the specified UUID in a remote GATT database. This command generates unique gatt_service event for every discovered primary service. Received gatt_procedure_completed event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t* gecko_cmd_gatt_discover_primary_services_by_uuid(uint8 connection,uint8 uuid_len,uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_by_uuid_id+((2+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
}
/**This command can be used to discover all characteristics of the defined GATT service from a remote GATT database. This command generates a unique gatt_characteristic event for every discovered characteristic. Received gatt_procedure_completed event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_characteristics_rsp_t* gecko_cmd_gatt_discover_characteristics(uint8 connection,uint32 service) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics.service=service;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics;
}
/**This command can be used to discover all the characteristics of the specified GATT service in a remote GATT database having the specified UUID. This command
generates a unique gatt_characteristic event for every discovered
characteristic having the specified UUID. Received gatt_procedure_completed event indicates that
this GATT procedure has successfully completed or failed with error.
            **/
static inline struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t* gecko_cmd_gatt_discover_characteristics_by_uuid(uint8 connection,uint32 service,uint8 uuid_len,uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.service=service;
	gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_by_uuid_id+((6+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
}
/**This command can be used to enable or disable the notifications and indications being sent from a remote GATT server. This procedure discovers a characteristic client configuration descriptor and writes the related configuration flags to a remote GATT database. A received gatt_procedure_completed event indicates that this GATT procedure has successfully completed or that is has failed with an error.**/
static inline struct gecko_msg_gatt_set_characteristic_notification_rsp_t* gecko_cmd_gatt_set_characteristic_notification(uint8 connection,uint16 characteristic,uint8 flags) 
{
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_gatt_set_characteristic_notification_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_set_characteristic_notification;
}
/**This command can be used to discover all the descriptors of the specified remote GATT characteristics in a remote GATT database. This command generates a unique gatt_descriptor event for every discovered descriptor. Received gatt_procedure_completed event indicates that this GATT procedure has succesfully completed or failed with error.**/
static inline struct gecko_msg_gatt_discover_descriptors_rsp_t* gecko_cmd_gatt_discover_descriptors(uint8 connection,uint16 characteristic) 
{
	gecko_cmd_msg->data.cmd_gatt_discover_descriptors.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_discover_descriptors.characteristic=characteristic;
	gecko_cmd_msg->header=gecko_cmd_gatt_discover_descriptors_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_discover_descriptors;
}
/**This command can be used to read the value of a characteristic from a remote GATT database. A single gatt_characteristic_value event is generated if the length of the characteristic value returned by the remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one gatt_characteristic_value event is generated because the firmware will automatically use the "read long" GATT procedure. Received gatt_procedure_completed event indicates that all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_characteristic_value_rsp_t* gecko_cmd_gatt_read_characteristic_value(uint8 connection,uint16 characteristic) 
{
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.characteristic=characteristic;
	gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value;
}
/**This command can be used to read the characteristic value of a service from a remote GATT database by giving the UUID of the characteristic and the handle of the service containing this characteristic. A single gatt_characteristic_value event is generated if the length of the characteristic value returned by the remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one gatt_characteristic_value event is generated because the firmware will automatically use the "read long" GATT procedure. Received gatt_procedure_completed event indicates that all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t* gecko_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection,uint32 service,uint8 uuid_len,uint8* uuid_data) 
{
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.service=service;
	gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.len=uuid_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.data,uuid_data,uuid_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_by_uuid_id+((6+uuid_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
}
/**This command can be used to write the value of a characteristic in a remote GATT database. If the length of the given value is greater than the exchanged GATT MTU (Message Transfer Unit), "write long" GATT procedure is used automatically. Received gatt_procedure_completed event indicates that all data has been written successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_write_characteristic_value_rsp_t* gecko_cmd_gatt_write_characteristic_value(uint8 connection,uint16 characteristic,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
}
/**This command can be used to write the value of a characteristic in a
remote GATT database. This command does not generate any event. All failures on the server are ignored silently. For example, if an error is generated in the remote GATT server and the given value is not written into database no error message willl be reported to the local GATT client.**/
static inline struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t* gecko_cmd_gatt_write_characteristic_value_without_response(uint8 connection,uint16 characteristic,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_without_response_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
}
/**This command can be used to add a characteristic value to the write
queue of a remote GATT server. More specifically, this command can be used in those special cases where very long attributes need to be written or values need to be written atomically such as in a case when there is a need to send the values of multiple different characteristics before sending the execute command. In all cases when the amount of data to transfer fits into the BGAPI payload the command gatt_write_characteristic_value is recommended also for writing long values since it transparently performs prepare_write and execute_write commands. A received gatt_characteristic_value event can
be used to verify that the data has been transmitted. Writes are executed or canceled by execute_characteristic_value_write command. Content, offset and length of given value is verified by the server when execute_characteristic_value_write is executed.
            **/
static inline struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.offset=offset;
	gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_prepare_characteristic_value_write_id+((6+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
}
/**This command can be used to commit or cancel previously queued writes to a long characteristic of a remote GATT server. Writes are sent to queue with prepare_characteristic_value_write command. Content, offset and length of queued values are validated by this procedure. A received gatt_procedure_completed event indicates that all data has been written succesfully or that an error response has been received.
            **/
static inline struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t* gecko_cmd_gatt_execute_characteristic_value_write(uint8 connection,uint8 flags) 
{
	gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_gatt_execute_characteristic_value_write_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_execute_characteristic_value_write;
}
/**This command must be used to send a characteristic confirmation to a remote GATT server after receiving an indication. The gatt_characteristic_value_event carries the att_opcode containing handle_value_indication (0x1e) which reveals that an indication has been received and this must be confirmed with this command. Confirmation needs to be sent within 30 seconds, otherwise the GATT transactions between the client and the server are discontinued.**/
static inline struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t* gecko_cmd_gatt_send_characteristic_confirmation(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_gatt_send_characteristic_confirmation.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_gatt_send_characteristic_confirmation_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_send_characteristic_confirmation;
}
/**This command can be used to read the descriptor value of a characteristic in a remote GATT database. A single gatt_descriptor_value event is generated if the length of the descriptor value returned by the remote GATT server is less than or equal to the size of the GATT MTU. If the length of the value exceeds the size of the GATT MTU more than one gatt_descriptor_value event is generated because the firmware will automatically use the "read long" GATT procedure. Received gatt_procedure_completed event indicates that all data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_descriptor_value_rsp_t* gecko_cmd_gatt_read_descriptor_value(uint8 connection,uint16 descriptor) 
{
	gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.descriptor=descriptor;
	gecko_cmd_msg->header=gecko_cmd_gatt_read_descriptor_value_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_descriptor_value;
}
/**This command can be used to write the value of a characteristic descriptor in a remote GATT database. If the length of the given value is greater than the exchanged GATT MTU size, "write long" GATT procedure is used automatically. Received gatt_procedure_completed event indicates that all data has been written succesfully or that an error response has been received.
            **/
static inline struct gecko_msg_gatt_write_descriptor_value_rsp_t* gecko_cmd_gatt_write_descriptor_value(uint8 connection,uint16 descriptor,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.descriptor=descriptor;
	gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_write_descriptor_value_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
}
/**This command can be used to find out if a service of a remote GATT database includes one or more other services. This command generates a unique gatt_service_completed event for each included service. This command generates a unique gatt_service event for every discovered service. Received gatt_procedure_completed event indicates that this GATT procedure has successfully completed or failed with error.**/
static inline struct gecko_msg_gatt_find_included_services_rsp_t* gecko_cmd_gatt_find_included_services(uint8 connection,uint32 service) 
{
	gecko_cmd_msg->data.cmd_gatt_find_included_services.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_find_included_services.service=service;
	gecko_cmd_msg->header=gecko_cmd_gatt_find_included_services_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_find_included_services;
}
/**With this single command it is possible read the values of multiple characteristics from a remote GATT database at once. gatt_characteristic_value events are generated as the values are returned by the remote GATT server.  Received gatt_procedure_completed event indicates that data has been read successfully or that an error response has been received.**/
static inline struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t* gecko_cmd_gatt_read_multiple_characteristic_values(uint8 connection,uint8 characteristic_list_len,uint8* characteristic_list_data) 
{
	gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.len=characteristic_list_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.data,characteristic_list_data,characteristic_list_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_read_multiple_characteristic_values_id+((2+characteristic_list_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
}
/**This command can be used to read the value of an attribute from a local GATT database.**/
static inline struct gecko_msg_gatt_server_read_attribute_value_rsp_t* gecko_cmd_gatt_server_read_attribute_value(uint16 attribute,uint16 offset) 
{
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.attribute=attribute;
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.offset=offset;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_value_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_value;
}
/**This command can be used to read the type of an attribute from a local GATT database. Type is usually given as 16-bit or 128-bit UUID.**/
static inline struct gecko_msg_gatt_server_read_attribute_type_rsp_t* gecko_cmd_gatt_server_read_attribute_type(uint16 attribute) 
{
	gecko_cmd_msg->data.cmd_gatt_server_read_attribute_type.attribute=attribute;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_type_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_type;
}
/**This command can be used to write the value of an attribute in the local GATT database. Writing the value of a characteristic of the local GATT database will not trigger notifications or indications to the remote GATT client in case such characteristic has property of indicate or notify and the client has enabled notification or indication. Notifications and indications are sent to the remote GATT client using send_characteristic_notification command.**/
static inline struct gecko_msg_gatt_server_write_attribute_value_rsp_t* gecko_cmd_gatt_server_write_attribute_value(uint16 attribute,uint16 offset,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.attribute=attribute;
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.offset=offset;
	gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_write_attribute_value_id+((5+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
}
/**This command must be used to send a response to a user_read_request event. The response needs to be sent within 30 seconds. otherwise no more GATT transactions are allowed by the remote side. If attr_errorcode is set to 0 the characteristic value is sent to the remote GATT client in the normal way. Other values will cause the local GATT server to send an attribute protocol error response instead of the actual data.**/
static inline struct gecko_msg_gatt_server_send_user_read_response_rsp_t* gecko_cmd_gatt_server_send_user_read_response(uint8 connection,uint16 characteristic,uint8 att_errorcode,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.att_errorcode=att_errorcode;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_read_response_id+((5+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
}
/**This command must be used to send a response to a user_write_request event. The response needs to be sent within 30 seconds. otherwise no more GATT transactions are allowed by the remote side. If attr_errorcode is set to 0 the ATT protocol's write response is sent to indicate to the remote GATT client that the write operation was processed successfully. Other values will cause the local GATT server to send an ATT protocol error response.**/
static inline struct gecko_msg_gatt_server_send_user_write_response_rsp_t* gecko_cmd_gatt_server_send_user_write_response(uint8 connection,uint16 characteristic,uint8 att_errorcode) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.att_errorcode=att_errorcode;
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_write_response_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_user_write_response;
}
/**This command can be used to send notifications and indications to a remote GATT client. Notification or indication is sent only if the client has enabled them by setting the corresponding flag to the Client Characteristic Configuration descriptor. A new notification or indication cannot be sent before a confirmation from the GATT client is first received. The confirmation is indicated by the event called gatt_server_characteristic_status_event.**/
static inline struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t* gecko_cmd_gatt_server_send_characteristic_notification(uint8 connection,uint16 characteristic,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.connection=connection;
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.characteristic=characteristic;
	gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_gatt_server_send_characteristic_notification_id+((4+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
}
/**This command can be used to send data to the defined endpoint.**/
static inline struct gecko_msg_endpoint_send_rsp_t* gecko_cmd_endpoint_send(uint8 endpoint,uint8 data_len,uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_endpoint_send.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_send.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_endpoint_send.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_endpoint_send_id+((2+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_send;
}
/**This command can be used to set the destination into which data from an endpoint will be routed to.**/
static inline struct gecko_msg_endpoint_set_streaming_destination_rsp_t* gecko_cmd_endpoint_set_streaming_destination(uint8 endpoint,uint8 destination_endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.destination_endpoint=destination_endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_set_streaming_destination_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_set_streaming_destination;
}
/**This command can be used to close an endpoint.**/
static inline struct gecko_msg_endpoint_close_rsp_t* gecko_cmd_endpoint_close(uint8 endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_close.endpoint=endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_close_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_close;
}
/**This command can be used to set endpoint flags to control and/or indicate in which mode the endpoint connection is operating.**/
static inline struct gecko_msg_endpoint_set_flags_rsp_t* gecko_cmd_endpoint_set_flags(uint8 endpoint,uint32 flags) 
{
	gecko_cmd_msg->data.cmd_endpoint_set_flags.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_set_flags.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_endpoint_set_flags_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_set_flags;
}
/**This command can be used to clear endpoint flags.**/
static inline struct gecko_msg_endpoint_clr_flags_rsp_t* gecko_cmd_endpoint_clr_flags(uint8 endpoint,uint32 flags) 
{
	gecko_cmd_msg->data.cmd_endpoint_clr_flags.endpoint=endpoint;
	gecko_cmd_msg->data.cmd_endpoint_clr_flags.flags=flags;
	gecko_cmd_msg->header=gecko_cmd_endpoint_clr_flags_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_clr_flags;
}
/**This command can be used to read the data performance counters (data sent counter and data received counter) of an endpoint.**/
static inline struct gecko_msg_endpoint_read_counters_rsp_t* gecko_cmd_endpoint_read_counters(uint8 endpoint) 
{
	gecko_cmd_msg->data.cmd_endpoint_read_counters.endpoint=endpoint;
	gecko_cmd_msg->header=gecko_cmd_endpoint_read_counters_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_endpoint_read_counters;
}
/**Start soft timer**/
static inline struct gecko_msg_hardware_set_soft_timer_rsp_t* gecko_cmd_hardware_set_soft_timer(uint32 time,uint8 handle,uint8 single_shot) 
{
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.time=time;
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.handle=handle;
	gecko_cmd_msg->data.cmd_hardware_set_soft_timer.single_shot=single_shot;
	gecko_cmd_msg->header=gecko_cmd_hardware_set_soft_timer_id+((6+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_set_soft_timer;
}
/**Configure I/O-port mode**/
static inline struct gecko_msg_hardware_configure_gpio_rsp_t* gecko_cmd_hardware_configure_gpio(uint8 port,uint8 gpio,uint8 mode,uint8 output) 
{
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.gpio=gpio;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.mode=mode;
	gecko_cmd_msg->data.cmd_hardware_configure_gpio.output=output;
	gecko_cmd_msg->header=gecko_cmd_hardware_configure_gpio_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_configure_gpio;
}
/**This command can be used to set the logic states of pins of the specified I/O-port using a bitmask.**/
static inline struct gecko_msg_hardware_write_gpio_rsp_t* gecko_cmd_hardware_write_gpio(uint8 port,uint16 mask,uint16 data) 
{
	gecko_cmd_msg->data.cmd_hardware_write_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_write_gpio.mask=mask;
	gecko_cmd_msg->data.cmd_hardware_write_gpio.data=data;
	gecko_cmd_msg->header=gecko_cmd_hardware_write_gpio_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_write_gpio;
}
/**This command can be used to read the pins of the specified I/O-port of the module.**/
static inline struct gecko_msg_hardware_read_gpio_rsp_t* gecko_cmd_hardware_read_gpio(uint8 port,uint16 mask) 
{
	gecko_cmd_msg->data.cmd_hardware_read_gpio.port=port;
	gecko_cmd_msg->data.cmd_hardware_read_gpio.mask=mask;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_gpio_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_gpio;
}
/**This command can be used to read the specified GPIO pin analog value.**/
static inline struct gecko_msg_hardware_read_adc_rsp_t* gecko_cmd_hardware_read_adc(uint8 port,uint8 pin) 
{
	gecko_cmd_msg->data.cmd_hardware_read_adc.port=port;
	gecko_cmd_msg->data.cmd_hardware_read_adc.pin=pin;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_adc_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_adc;
}
/**This command can be used for reading the specified I2C interface.**/
static inline struct gecko_msg_hardware_read_i2c_rsp_t* gecko_cmd_hardware_read_i2c(uint8 channel,uint16 slave_address,uint8 length) 
{
	gecko_cmd_msg->data.cmd_hardware_read_i2c.channel=channel;
	gecko_cmd_msg->data.cmd_hardware_read_i2c.slave_address=slave_address;
	gecko_cmd_msg->data.cmd_hardware_read_i2c.length=length;
	gecko_cmd_msg->header=gecko_cmd_hardware_read_i2c_id+((4+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_read_i2c;
}
/**This command can be used to write data into I2C interface.**/
static inline struct gecko_msg_hardware_write_i2c_rsp_t* gecko_cmd_hardware_write_i2c(uint8 channel,uint16 slave_address,uint8 data_len,uint8* data_data) 
{
	gecko_cmd_msg->data.cmd_hardware_write_i2c.channel=channel;
	gecko_cmd_msg->data.cmd_hardware_write_i2c.slave_address=slave_address;
	gecko_cmd_msg->data.cmd_hardware_write_i2c.data.len=data_len;
	memcpy(gecko_cmd_msg->data.cmd_hardware_write_i2c.data.data,data_data,data_len);
	gecko_cmd_msg->header=gecko_cmd_hardware_write_i2c_id+((4+data_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_write_i2c;
}
/**This command can be used to stop I2C transmission.**/
static inline struct gecko_msg_hardware_stop_i2c_rsp_t* gecko_cmd_hardware_stop_i2c(uint8 channel) 
{
	gecko_cmd_msg->data.cmd_hardware_stop_i2c.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_hardware_stop_i2c_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_hardware_stop_i2c;
}
/**This command can be used to retrieve all PS keys and their current values. For each existing PS key a flash_pskey event will be generated which includes the corresponding PS key value.**/
static inline struct gecko_msg_flash_ps_dump_rsp_t* gecko_cmd_flash_ps_dump() 
{
	gecko_cmd_msg->header=gecko_cmd_flash_ps_dump_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_dump;
}
/**This command can be used to erase all PS keys and their corresponding value.**/
static inline struct gecko_msg_flash_ps_erase_all_rsp_t* gecko_cmd_flash_ps_erase_all() 
{
	gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_all_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_erase_all;
}
/**This command can be used to store a value into the specified PS key.**/
static inline struct gecko_msg_flash_ps_save_rsp_t* gecko_cmd_flash_ps_save(uint16 key,uint8 value_len,uint8* value_data) 
{
	gecko_cmd_msg->data.cmd_flash_ps_save.key=key;
	gecko_cmd_msg->data.cmd_flash_ps_save.value.len=value_len;
	memcpy(gecko_cmd_msg->data.cmd_flash_ps_save.value.data,value_data,value_len);
	gecko_cmd_msg->header=gecko_cmd_flash_ps_save_id+((3+value_len)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_save;
}
/**This command can be used for retrieving the value of the specified PS key.**/
static inline struct gecko_msg_flash_ps_load_rsp_t* gecko_cmd_flash_ps_load(uint16 key) 
{
	gecko_cmd_msg->data.cmd_flash_ps_load.key=key;
	gecko_cmd_msg->header=gecko_cmd_flash_ps_load_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_load;
}
/**This command can be used to erase a single PS key and its value from the persistent store..**/
static inline struct gecko_msg_flash_ps_erase_rsp_t* gecko_cmd_flash_ps_erase(uint16 key) 
{
	gecko_cmd_msg->data.cmd_flash_ps_erase.key=key;
	gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_flash_ps_erase;
}
/**Direct test mode, Start TX test**/
static inline struct gecko_msg_test_dtm_tx_rsp_t* gecko_cmd_test_dtm_tx(uint8 packet_type,uint8 length,uint8 channel) 
{
	gecko_cmd_msg->data.cmd_test_dtm_tx.packet_type=packet_type;
	gecko_cmd_msg->data.cmd_test_dtm_tx.length=length;
	gecko_cmd_msg->data.cmd_test_dtm_tx.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_test_dtm_tx_id+((3+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_tx;
}
/**Direct Test Mode, Start RX test mode**/
static inline struct gecko_msg_test_dtm_rx_rsp_t* gecko_cmd_test_dtm_rx(uint8 channel) 
{
	gecko_cmd_msg->data.cmd_test_dtm_rx.channel=channel;
	gecko_cmd_msg->header=gecko_cmd_test_dtm_rx_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_rx;
}
/**Direct Test Mode, Request to end test**/
static inline struct gecko_msg_test_dtm_end_rsp_t* gecko_cmd_test_dtm_end() 
{
	gecko_cmd_msg->header=gecko_cmd_test_dtm_end_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_test_dtm_end;
}
/**This command can be used to set the device into bondable mode.**/
static inline struct gecko_msg_sm_set_bondable_mode_rsp_t* gecko_cmd_sm_set_bondable_mode(uint8 bondable) 
{
	gecko_cmd_msg->data.cmd_sm_set_bondable_mode.bondable=bondable;
	gecko_cmd_msg->header=gecko_cmd_sm_set_bondable_mode_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_set_bondable_mode;
}
/**This command can be used to configure  authentication methods and I/O capabilities of the system.**/
static inline void* gecko_cmd_sm_configure(uint8 mitm_required,uint8 io_capabilities) 
{
	gecko_cmd_msg->data.cmd_sm_configure.mitm_required=mitm_required;
	gecko_cmd_msg->data.cmd_sm_configure.io_capabilities=io_capabilities;
	gecko_cmd_msg->header=gecko_cmd_sm_configure_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.payload;
}
/**Set maximum allowed bonding count.**/
static inline struct gecko_msg_sm_store_bonding_configuration_rsp_t* gecko_cmd_sm_store_bonding_configuration(uint8 max_bonding_count,uint8 policy_flags) 
{
	gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.max_bonding_count=max_bonding_count;
	gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.policy_flags=policy_flags;
	gecko_cmd_msg->header=gecko_cmd_sm_store_bonding_configuration_id+((2+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_store_bonding_configuration;
}
/**This command can be used to enhance the security of a connection to current security requirements. **/
static inline struct gecko_msg_sm_increase_security_rsp_t* gecko_cmd_sm_increase_security(uint8 connection) 
{
	gecko_cmd_msg->data.cmd_sm_increase_security.connection=connection;
	gecko_cmd_msg->header=gecko_cmd_sm_increase_security_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_increase_security;
}
/**This command can be used to delete specified bonding information from persistent store.**/
static inline struct gecko_msg_sm_delete_bonding_rsp_t* gecko_cmd_sm_delete_bonding(uint8 bonding) 
{
	gecko_cmd_msg->data.cmd_sm_delete_bonding.bonding=bonding;
	gecko_cmd_msg->header=gecko_cmd_sm_delete_bonding_id+((1+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_delete_bonding;
}
/**This command can be used to delete all bonding information from persistent store.**/
static inline struct gecko_msg_sm_delete_bondings_rsp_t* gecko_cmd_sm_delete_bondings() 
{
	gecko_cmd_msg->header=gecko_cmd_sm_delete_bondings_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_delete_bondings;
}
/**This command can be used to enter a passkey after receiving a passkey request event.**/
static inline struct gecko_msg_sm_enter_passkey_rsp_t* gecko_cmd_sm_enter_passkey(uint8 connection,uint32 passkey) 
{
	gecko_cmd_msg->data.cmd_sm_enter_passkey.connection=connection;
	gecko_cmd_msg->data.cmd_sm_enter_passkey.passkey=passkey;
	gecko_cmd_msg->header=gecko_cmd_sm_enter_passkey_id+((5+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_enter_passkey;
}
/**This command can be used to list all bondings stored in the bonding database. Bondings are reported by using the sm_list_bonding_event for each bonding and the report is ended with sm_list_all_bonding_complete event. Recommended to be used only for debugging purposes.**/
static inline struct gecko_msg_sm_list_all_bondings_rsp_t* gecko_cmd_sm_list_all_bondings() 
{
	gecko_cmd_msg->header=gecko_cmd_sm_list_all_bondings_id+((0+0)<<8);
	gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);

	return &gecko_rsp_msg->data.rsp_sm_list_all_bondings;
}
#endif
